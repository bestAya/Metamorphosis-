# 函数式编程

## 范畴轮

* 函数式编程是范畴轮的数学分支是一门很复杂的数学，认为世界上所有概念体系都可以抽象出一个个范畴
* 彼此之间存在某种关系概念、事务、对象等等，都构成范畴。任何事物之间只要找出他们的关系就能定义
* 箭头函数标识范畴成员之间的关系，正式的名称叫做“态射”。范畴论认为，同一个范畴的所有成员就是不同状态的“变形”。通过态射一个成员可以变形成另一个成员

## 基础理论

> 函数式编程不是用函数来编程，也不是传统的面向过程编程。主要在于复杂的函数合成简单的函数。运算过程尽量写成一系列嵌套的函数调用
> 主要思想是把运算过程尽量写成一系列嵌套的函数调用

```js
    //传统函数
    var a = 1 + 2;
　　 var b = a * 3;
　　 var c = b - 4;
    //函数式编程
    var result = subtract(multiply(add(1,2), 3), 4);
```

## 函数式编程的特点

* 函数是'一等公民'
    >所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值
* 只有表达式
    >"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
    >原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。
* 没有副作用
  * 纯函数

    >输入相同的参数，返回相同值。

    ```js
        const sum = (x, y) => x + y;
        sun(10,2) //12
        sun(10,2) //12
    ```

  * 非纯函数

    >在参数一致的情况下，返回值可能不一致的函数。

    ```js
        let seed = 0; // 定义一个外部变量
        // 另一个用于求和的函数
        const sum = (x, y) => x + y + (++seed);
         sun(10,2) //13
         sun(10,2) //14
    ```

* 不修改状态

    >上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。

* 引用透明

    >引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。
    >有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。

## 函数式编程的意义

* 代码简洁,开发速度快
  >函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。
* 接近自然语言，易于理解

  ```js
        //表达式(1 + 2) * 3 - 4，写成函数式语言：
        subtract(multiply(add(1,2), 3), 4)//变形
        add(1,2).multiply(3).subtract(4)//变形
        merge([1,2],[3,4]).sort().search("2")//变形
  ```

* 跟方便代码管理
  >函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。
* 易于'并发编程'
  >数式编程不需要考虑"死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署"并发编程"（concurrency）。
* 代码热升级
  >函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。
  
### 函数的柯里化

>传递给函数一部分参数来调用它,然后在返回一个函数。
>柯里化是一种“预加载”函数的方法，传递较少的参数，得到一个已经记忆住的函数，某总意义上是一种缓存。

### 偏应用函数

### 函数的组合

### 惰性求值 惰性函数 惰性链


* 高阶函数
* 尾调用优化
  * 一种浏览器自己实现，另一个手动实现
* 闭包
* 容器，functor
* 错误处理 Either、AP
* IO
* Monad

